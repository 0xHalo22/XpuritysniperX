# ğŸš¨ PURITY SNIPER BOT - CRITICAL FIX PRD

## ğŸ¯ **Emergency Recovery Objective**
Fix the broken bot that currently crashes on SOL interactions and has missing core functionality. The bot should work flawlessly within 4 hours of development.

## ğŸ“Š **Current Broken State Analysis**

### âŒ **Critical Failures Identified**
1. **SOL Handlers Missing**: Bot crashes when users click SOL buttons
2. **Incomplete Function Definitions**: Many functions referenced but not implemented
3. **Conflicting Startup Logic**: Multiple `startBot()` functions causing conflicts
4. **Missing Environment Validation**: Only checks `BOT_TOKEN`, ignores other critical vars
5. **Broken Message Processing**: SOL message handlers incomplete

### ğŸ” **Specific Missing Components**
```javascript
// These functions are called but NOT defined:
- showSolSnipeConfiguration()
- getSolWalletAddress()
- getSolWalletForTrading()
- showSolTokenHoldings()
- showSolBuyAmountSelection()
- showSolBuyReview()
- showSolSellReview()

// These callback handlers are missing:
- sol_buy_amount_*
- sol_buy_execute_*
- sol_sell_percentage_*
- sol_sell_execute_*
- sol_custom_amount message processing
```

---

## ğŸ› ï¸ **Fix Implementation Strategy**

### **Phase 1: Core Stability (30 minutes)**
Fix the fundamental issues that prevent the bot from running

### **Phase 2: SOL Functionality (90 minutes)**
Implement all missing SOL handlers and functions

### **Phase 3: Message Processing (45 minutes)**
Complete the text message handling system

### **Phase 4: Testing & Polish (45 minutes)**
Test all flows and fix edge cases

---

## ğŸ“‹ **Detailed Fix Requirements**

### **1. STARTUP & ENVIRONMENT FIXES**

#### **1.1 Environment Validation**
```javascript
// CURRENT (broken):
function validateEnvironment() {
  const required = ['BOT_TOKEN'];
  // Only checks one variable
}

// REQUIRED (fixed):
function validateEnvironment() {
  const required = ['BOT_TOKEN', 'ETH_RPC_URL', 'TREASURY_WALLET'];
  const optional = ['SOL_RPC_URL', 'ENCRYPTION_KEY'];
  
  // Validate required vars
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    console.error('âŒ Missing required environment variables:', missing.join(', '));
    console.error('ğŸ’¡ Set these in Secrets tab or .env file:');
    missing.forEach(key => {
      console.error(`   ${key}=your_${key.toLowerCase()}_value`);
    });
    process.exit(1);
  }
  
  // Warn about optional vars
  optional.forEach(key => {
    if (!process.env[key]) {
      console.log(`âš ï¸ Optional variable ${key} not set - some features disabled`);
    }
  });
  
  console.log('âœ… Environment variables validated');
}
```

#### **1.2 Single Startup Function**
```javascript
// CURRENT (broken): Multiple conflicting startBot() functions

// REQUIRED (fixed): One clean startup function
async function startBot() {
  try {
    // Step 1: Validate environment
    validateEnvironment();
    
    // Step 2: Initialize storage
    await initializeStorage();
    
    // Step 3: Initialize blockchain connections
    await initializeBlockchains();
    
    // Step 4: Start bot
    await bot.launch({
      allowedUpdates: ['message', 'callback_query'],
      polling: { timeout: 30, limit: 100 }
    });
    
    console.log('âœ… Purity Sniper Bot is running!');
    console.log('ğŸŸ  ETH functionality: Ready');
    console.log('ğŸŸ£ SOL functionality: Ready');
    console.log('ğŸ’° Revenue collection: Active');
    
  } catch (error) {
    console.error('âŒ Bot startup failed:', error.message);
    process.exit(1);
  }
}
```

### **2. SOL WALLET FUNCTIONALITY FIXES**

#### **2.1 SOL Wallet Address Management**
```javascript
// CURRENT (broken): Function called but not defined

// REQUIRED (fixed):
async function getSolWalletAddress(userId, userData) {
  if (!userData.solWallets || userData.solWallets.length === 0) {
    throw new Error('No SOL wallet found. Please import a wallet first.');
  }
  
  const activeIndex = userData.activeSolWallet || 0;
  if (activeIndex >= userData.solWallets.length) {
    throw new Error('Active wallet index invalid. Please re-import wallet.');
  }
  
  // For demo: return mock address
  // For production: decrypt and derive public key
  return userData.solWallets[activeIndex].address || 'DEMO_SOL_ADDRESS';
}

async function getSolWalletForTrading(userId, userData) {
  if (!userData.solWallets || userData.solWallets.length === 0) {
    throw new Error('No SOL wallet available for trading');
  }
  
  const activeIndex = userData.activeSolWallet || 0;
  const walletData = userData.solWallets[activeIndex];
  
  // For demo: return mock keypair
  // For production: decrypt private key and create Keypair
  return {
    keypair: 'DEMO_KEYPAIR',
    address: walletData.address || 'DEMO_SOL_ADDRESS'
  };
}
```

#### **2.2 SOL Wallet Import Handler**
```javascript
// REQUIRED: Complete SOL wallet import flow
bot.action('import_sol_wallet', async (ctx) => {
  const userId = ctx.from.id.toString();

  await ctx.editMessageText(
    `ğŸŸ£ **IMPORT SOL WALLET**

Send your Solana private key:

**Supported Formats:**
â€¢ Base58 private key (recommended)
â€¢ JSON array format: [1,2,3,...]
â€¢ Hex format: 0x1234...

**Security:** Your key will be encrypted with AES-256

Send your private key now:`,
    {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'âŒ Cancel', callback_data: 'sol_wallet' }]
        ]
      },
      parse_mode: 'Markdown'
    }
  );

  userStates.set(userId, {
    action: 'waiting_sol_private_key',
    timestamp: Date.now()
  });
});
```

### **3. SOL BUY FLOW - COMPLETE IMPLEMENTATION**

#### **3.1 Token Address Input Handler**
```javascript
// REQUIRED: Handle SOL token address input
bot.action('sol_buy', async (ctx) => {
  const userId = ctx.from.id.toString();
  const userData = await loadUserData(userId);

  // Check wallet requirement
  if (!userData.solWallets || userData.solWallets.length === 0) {
    await ctx.editMessageText(
      `ğŸŸ£ **SOL BUY TOKEN**

âŒ No SOL wallet found. Import a wallet first to start trading.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'â• Import SOL Wallet', callback_data: 'import_sol_wallet' }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        }
      }
    );
    return;
  }

  await ctx.editMessageText(
    `ğŸŸ£ **SOL BUY TOKEN**

Enter the SPL token mint address you want to buy:

**Examples:**
â€¢ BONK: DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263
â€¢ USDC: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v

**Format:** Base58 address (44 characters)

Send the token mint address now:`,
    {
      reply_markup: {
        inline_keyboard: [[
          { text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }
        ]]
      },
      parse_mode: 'Markdown'
    }
  );

  userStates.set(userId, {
    action: 'sol_token_address',
    timestamp: Date.now()
  });
});
```

#### **3.2 Amount Selection Function**
```javascript
// REQUIRED: Missing function implementation
async function showSolBuyAmountSelection(ctx, tokenMint) {
  const userId = ctx.from.id.toString();
  
  try {
    const userData = await loadUserData(userId);
    const walletAddress = await getSolWalletAddress(userId, userData);
    const balance = await solChain.getBalance(walletAddress);

    // Get token info (for production, call Jupiter API)
    const tokenInfo = {
      symbol: 'TOKEN',
      name: 'Demo Token',
      decimals: 9
    };

    const keyboard = [
      [
        { text: 'ğŸ’ 0.1 SOL', callback_data: `sol_buy_amount_${tokenMint}_0.1` },
        { text: 'ğŸ’ 0.25 SOL', callback_data: `sol_buy_amount_${tokenMint}_0.25` }
      ],
      [
        { text: 'ğŸ’ 0.5 SOL', callback_data: `sol_buy_amount_${tokenMint}_0.5` },
        { text: 'ğŸ’ 1.0 SOL', callback_data: `sol_buy_amount_${tokenMint}_1.0` }
      ],
      [
        { text: 'ğŸ’ 2.0 SOL', callback_data: `sol_buy_amount_${tokenMint}_2.0` },
        { text: 'ğŸ’ 5.0 SOL', callback_data: `sol_buy_amount_${tokenMint}_5.0` }
      ],
      [{ text: 'âœï¸ Custom Amount', callback_data: `sol_buy_custom_${tokenMint}` }],
      [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
    ];

    await ctx.editMessageText(
      `ğŸŸ£ **SOL BUY TOKEN**

**Token:** ${tokenInfo.symbol} (${tokenInfo.name})
**Mint:** ${tokenMint.slice(0, 8)}...${tokenMint.slice(-4)}
**Your SOL Balance:** ${balance} SOL

Choose SOL amount to spend:

ğŸ’¡ **Fee Info:** 1% service fee (0.5% for premium users)
â›½ **Gas:** ~0.005 SOL estimated`,
      {
        reply_markup: { inline_keyboard: keyboard },
        parse_mode: 'Markdown'
      }
    );

  } catch (error) {
    console.log('Error showing SOL buy amount selection:', error);
    await ctx.editMessageText(
      `âŒ **Error loading token information**

${error.message}

Please verify the token address and try again.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Different Token', callback_data: 'sol_buy' }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        }
      }
    );
  }
}
```

#### **3.3 Missing Callback Handlers**
```javascript
// REQUIRED: All missing SOL buy callbacks

// Amount selection callbacks
bot.action(/^sol_buy_amount_(.+)_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const amount = ctx.match[2];
  await showSolBuyReview(ctx, tokenMint, amount);
});

// Custom amount callback
bot.action(/^sol_buy_custom_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const userId = ctx.from.id.toString();

  await ctx.editMessageText(
    `ğŸŸ£ **CUSTOM SOL AMOUNT**

Enter the SOL amount you want to spend:

**Examples:**
â€¢ 0.25 (quarter SOL)
â€¢ 1.5 (one and half SOL)
â€¢ 10 (ten SOL)

**Minimum:** 0.01 SOL
**Maximum:** Your wallet balance

Send your custom amount now:`,
    {
      reply_markup: {
        inline_keyboard: [[
          { text: 'ğŸ”™ Back to Amount Selection', callback_data: `sol_buy_retry_${tokenMint}` }
        ]]
      },
      parse_mode: 'Markdown'
    }
  );

  userStates.set(userId, {
    action: 'sol_custom_amount',
    tokenAddress: tokenMint,
    timestamp: Date.now()
  });
});

// Retry callback
bot.action(/^sol_buy_retry_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  await showSolBuyAmountSelection(ctx, tokenMint);
});

// Execute callback
bot.action(/^sol_buy_execute_(.+)_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const amount = ctx.match[2];
  const userId = ctx.from.id.toString();

  try {
    // Rate limiting check
    await checkRateLimit(userId, 'transactions');

    await ctx.editMessageText('â³ **Executing SOL token purchase...**\n\nğŸ”„ Getting best route via Jupiter...\nâš¡ Preparing transaction...');

    const userData = await loadUserData(userId);
    const wallet = await getSolWalletForTrading(userId, userData);

    // Calculate fees
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const feeCalculation = solChain.calculateFee(amount, feePercent);

    // Execute swap (mock for now)
    const swapResult = await solChain.executeSwap({
      tokenIn: 'SOL',
      tokenOut: tokenMint,
      amount: feeCalculation.netAmount,
      wallet: wallet,
      slippage: userData.settings?.slippage || 3
    });

    // Collect fee to treasury
    let feeResult = null;
    if (parseFloat(feeCalculation.feeAmount) > 0) {
      try {
        feeResult = await solChain.sendFeeToTreasury(wallet.keypair, feeCalculation.feeAmount);
      } catch (feeError) {
        console.log('SOL buy fee collection failed (non-blocking):', feeError.message);
      }
    }

    // Record transaction
    await recordTransaction(userId, {
      type: 'buy',
      chain: 'solana',
      tokenAddress: tokenMint,
      amount: amount,
      tokensReceived: swapResult.outputAmount,
      feeAmount: feeCalculation.feeAmount,
      txHash: swapResult.signature,
      feeHash: feeResult?.signature || null,
      timestamp: Date.now()
    });

    await ctx.editMessageText(
      `âœ… **SOL PURCHASE SUCCESSFUL!**

**SOL Spent:** ${amount} SOL
**Tokens Received:** ${parseFloat(swapResult.outputAmount).toLocaleString()} tokens
**Service Fee:** ${feeCalculation.feeAmount} SOL (${feePercent}%)
**Net Traded:** ${feeCalculation.netAmount} SOL

**Transaction:** [View on Solscan](https://solscan.io/tx/${swapResult.signature})
**Signature:** \`${swapResult.signature}\`

ğŸ’ Tokens have been added to your wallet!`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ’° Buy More', callback_data: 'sol_buy' }],
            [{ text: 'ğŸ“ˆ Sell Tokens', callback_data: 'sol_sell' }],
            [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );

    console.log(`âœ… Successful SOL buy: User ${userId}, Token ${tokenMint}, Amount ${amount} SOL`);

  } catch (error) {
    console.log('SOL buy execution error:', error);
    await ctx.editMessageText(
      `âŒ **PURCHASE FAILED**

**Error:** ${error.message}

Your SOL is safe - no transaction was completed.

**Common Issues:**
â€¢ Insufficient SOL balance
â€¢ Invalid token address
â€¢ Network congestion
â€¢ Slippage too low`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Again', callback_data: `sol_buy_retry_${tokenMint}` }],
            [{ text: 'âš™ï¸ Adjust Settings', callback_data: 'settings' }],
            [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
  }
});
```

### **4. SOL SELL FLOW - COMPLETE IMPLEMENTATION**

#### **4.1 Token Holdings Function**
```javascript
// REQUIRED: Missing function implementation
async function showSolTokenHoldings(ctx, userId) {
  try {
    const userData = await loadUserData(userId);
    const walletAddress = await getSolWalletAddress(userId, userData);

    await ctx.editMessageText('â³ **Loading your SPL tokens...**\n\nğŸ” Scanning wallet for tokens...\nğŸ“Š Calculating balances...');

    // Get token holdings (mock for demo, use Jupiter/Helius for production)
    const tokenHoldings = await solChain.getTokenHoldings(walletAddress);

    if (tokenHoldings.length === 0) {
      await ctx.editMessageText(
        `ğŸŸ£ **SOL SELL TOKEN**

âŒ No SPL tokens found in your wallet.

**Possible reasons:**
â€¢ You haven't bought any tokens yet
â€¢ Tokens are in a different wallet
â€¢ Network sync issues

Buy some tokens first to start selling!`,
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ğŸ’° Buy Tokens', callback_data: 'sol_buy' }],
              [{ text: 'ğŸ”„ Refresh', callback_data: 'sol_sell' }],
              [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
            ]
          },
          parse_mode: 'Markdown'
        }
      );
      return;
    }

    // Format token list
    let tokensText = `ğŸŸ£ **SOL SELL TOKEN**\n\n**Your SPL Token Holdings:**\n\n`;
    const keyboard = [];

    tokenHoldings.forEach((token, index) => {
      const displayBalance = parseFloat(token.balance).toLocaleString();
      const estimatedValue = parseFloat(token.usdValue || 0).toFixed(2);
      
      tokensText += `**${index + 1}.** ${token.symbol} (${token.name})\n`;
      tokensText += `   ğŸ’° Balance: ${displayBalance}\n`;
      tokensText += `   ğŸ’µ Est. Value: $${estimatedValue}\n`;
      tokensText += `   ğŸ“ ${token.mint.slice(0, 8)}...${token.mint.slice(-4)}\n\n`;

      keyboard.push([{ 
        text: `ğŸ“ˆ Sell ${token.symbol}`, 
        callback_data: `sol_sell_token_${token.mint}` 
      }]);
    });

    tokensText += `ğŸ’¡ **Tip:** Choose a token to see selling options\nğŸ“Š **Total Tokens:** ${tokenHoldings.length}`;

    keyboard.push([{ text: 'ğŸ”„ Refresh Holdings', callback_data: 'sol_sell' }]);
    keyboard.push([{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]);

    await ctx.editMessageText(tokensText, {
      reply_markup: { inline_keyboard: keyboard },
      parse_mode: 'Markdown'
    });

  } catch (error) {
    console.log('Error loading SOL token holdings:', error);
    await ctx.editMessageText(
      `âŒ **Error loading token holdings**

${error.message}

**Troubleshooting:**
â€¢ Check your internet connection
â€¢ Verify wallet is imported correctly
â€¢ Try refreshing in a few seconds`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Again', callback_data: 'sol_sell' }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
  }
}
```

#### **4.2 Missing Sell Callback Handlers**
```javascript
// REQUIRED: All missing SOL sell callbacks

// Token selection callback
bot.action(/^sol_sell_token_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  
  try {
    const userId = ctx.from.id.toString();
    const userData = await loadUserData(userId);
    
    // Get token balance (mock for demo)
    const tokenBalance = 1000; // Replace with actual balance lookup
    const tokenSymbol = 'TOKEN'; // Replace with actual symbol lookup
    
    const keyboard = [
      [
        { text: 'ğŸ“ˆ 25%', callback_data: `sol_sell_percentage_${tokenMint}_25` },
        { text: 'ğŸ“ˆ 50%', callback_data: `sol_sell_percentage_${tokenMint}_50` }
      ],
      [
        { text: 'ğŸ“ˆ 75%', callback_data: `sol_sell_percentage_${tokenMint}_75` },
        { text: 'ğŸ“ˆ 100%', callback_data: `sol_sell_percentage_${tokenMint}_100` }
      ],
      [{ text: 'âœï¸ Custom Amount', callback_data: `sol_sell_custom_${tokenMint}` }],
      [{ text: 'ğŸ”™ Back to Holdings', callback_data: 'sol_sell' }]
    ];

    await ctx.editMessageText(
      `ğŸŸ£ **SELL ${tokenSymbol} TOKEN**

**Token:** ${tokenMint.slice(0, 8)}...${tokenMint.slice(-4)}
**Your Balance:** ${tokenBalance.toLocaleString()} ${tokenSymbol}
**Est. SOL Value:** ~2.5 SOL

Choose sell percentage:

ğŸ’¡ **Service Fee:** 1% of SOL received (0.5% for premium)
âš¡ **Speed:** Near-instant execution via Jupiter`,
      {
        reply_markup: { inline_keyboard: keyboard },
        parse_mode: 'Markdown'
      }
    );

  } catch (error) {
    console.log('Error in sol_sell_token handler:', error);
    await ctx.editMessageText(
      `âŒ **Error loading token details**

Please try selecting the token again.`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ Back to Holdings', callback_data: 'sol_sell' }
          ]]
        }
      }
    );
  }
});

// Percentage selection callbacks
bot.action(/^sol_sell_percentage_(.+)_(\d+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const percentage = parseInt(ctx.match[2]);
  await showSolSellReview(ctx, tokenMint, percentage);
});

// Custom amount callback
bot.action(/^sol_sell_custom_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const userId = ctx.from.id.toString();

  await ctx.editMessageText(
    `ğŸŸ£ **CUSTOM SELL AMOUNT**

Enter the number of tokens you want to sell:

**Examples:**
â€¢ 100 (sell 100 tokens)
â€¢ 1500.5 (sell 1500.5 tokens)
â€¢ 0.001 (sell very small amount)

**Your Balance:** 1000 tokens (demo)

Send the amount now:`,
    {
      reply_markup: {
        inline_keyboard: [[
          { text: 'ğŸ”™ Back to Percentage Selection', callback_data: `sol_sell_token_${tokenMint}` }
        ]]
      },
      parse_mode: 'Markdown'
    }
  );

  userStates.set(userId, {
    action: 'sol_sell_custom_amount',
    tokenAddress: tokenMint,
    timestamp: Date.now()
  });
});

// Execute sell callback
bot.action(/^sol_sell_execute_(.+)_(.+)$/, async (ctx) => {
  const tokenMint = ctx.match[1];
  const amountOrPercentage = ctx.match[2];
  const userId = ctx.from.id.toString();

  try {
    await checkRateLimit(userId, 'transactions');

    await ctx.editMessageText('â³ **Executing SOL token sale...**\n\nğŸ”„ Getting best route via Jupiter...\nâš¡ Preparing transaction...');

    const userData = await loadUserData(userId);
    const wallet = await getSolWalletForTrading(userId, userData);

    // Calculate sell amount
    const isPercentage = !amountOrPercentage.includes('.');
    const sellAmount = isPercentage ? 
      (1000 * parseInt(amountOrPercentage) / 100) : // Mock calculation
      parseFloat(amountOrPercentage);

    // Execute swap (mock for now)
    const swapResult = await solChain.executeSwap({
      tokenIn: tokenMint,
      tokenOut: 'SOL',
      amount: sellAmount,
      wallet: wallet,
      slippage: userData.settings?.slippage || 3
    });

    // Calculate fees
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const solReceived = parseFloat(swapResult.outputAmount);
    const feeCalculation = solChain.calculateFee(solReceived, feePercent);

    // Collect fee to treasury
    let feeResult = null;
    if (parseFloat(feeCalculation.feeAmount) > 0) {
      try {
        feeResult = await solChain.sendFeeToTreasury(wallet.keypair, feeCalculation.feeAmount);
      } catch (feeError) {
        console.log('SOL sell fee collection failed (non-blocking):', feeError.message);
      }
    }

    // Record transaction
    await recordTransaction(userId, {
      type: 'sell',
      chain: 'solana',
      tokenAddress: tokenMint,
      amount: sellAmount.toString(),
      solReceived: feeCalculation.netAmount,
      feeAmount: feeCalculation.feeAmount,
      txHash: swapResult.signature,
      feeHash: feeResult?.signature || null,
      timestamp: Date.now()
    });

    await ctx.editMessageText(
      `âœ… **SOL SELL SUCCESSFUL!**

**Tokens Sold:** ${sellAmount.toLocaleString()} tokens
**SOL Received:** ${feeCalculation.netAmount} SOL
**Service Fee:** ${feeCalculation.feeAmount} SOL (${feePercent}%)
**Total SOL:** ${solReceived.toFixed(6)} SOL

**Transaction:** [View on Solscan](https://solscan.io/tx/${swapResult.signature})
**Signature:** \`${swapResult.signature}\`

ğŸ’° SOL has been added to your wallet!`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ“ˆ Sell More', callback_data: 'sol_sell' }],
            [{ text: 'ğŸ’° Buy Tokens', callback_data: 'sol_buy' }],
            [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );

    console.log(`âœ… Successful SOL sell: User ${userId}, Token ${tokenMint}, Amount ${sellAmount} tokens`);

  } catch (error) {
    console.log('SOL sell execution error:', error);
    await ctx.editMessageText(
      `âŒ **SELL FAILED**

**Error:** ${error.message}

Your tokens are safe - no transaction was completed.

**Common Issues:**
â€¢ Network congestion
â€¢ Insufficient liquidity
â€¢ Slippage too low
â€¢ Invalid token balance`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Again', callback_data: `sol_sell_token_${tokenMint}` }],
            [{ text: 'âš™ï¸ Adjust Settings', callback_data: 'settings' }],
            [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
  }
});
```

### **5. MESSAGE PROCESSING FIXES**

#### **5.1 Complete Text Message Handler**
```javascript
// CURRENT (broken): Incomplete message processing

// REQUIRED (fixed): Complete text message handler
bot.on('text', async (ctx) => {
  const userId = ctx.from.id.toString();
  const userState = userStates.get(userId);
  const text = ctx.message.text.trim();

  // Skip if no active state
  if (!userState) {
    // Optional: Handle unexpected messages
    await ctx.reply(
      'ğŸ‘‹ Welcome to Purity Sniper Bot!\n\nUse the buttons below to get started:',
      {
        reply_markup: {
          inline_keyboard: getMainMenuKeyboard()
        }
      }
    );
    return;
  }

  try {
    // Route based on action
    switch (userState.action) {
      case 'waiting_eth_private_key':
        await handleEthPrivateKeyImport(ctx, userId, text);
        break;
        
      case 'waiting_sol_private_key':
        await handleSolPrivateKeyImport(ctx, userId, text);
        break;
        
      case 'sol_token_address':
        await handleSolTokenAddress(ctx, userId, text);
        break;
        
      case 'sol_custom_amount':
        await handleSolCustomAmount(ctx, userId, text, userState.tokenAddress);
        break;
        
      case 'sol_sell_custom_amount':
        await handleSolSellCustomAmount(ctx, userId, text, userState.tokenAddress);
        break;
        
      case 'waiting_token_address':
        await handleEthTokenAddress(ctx, userId, text);
        break;
        
      case 'waiting_custom_amount':
        await handleEthCustomAmount(ctx, userId, text, userState.tokenAddress);
        break;
        
      case 'waiting_sell_token_address':
        await handleEthSellTokenAddress(ctx, userId, text);
        break;
        
      case 'waiting_sell_custom_amount':
        await handleEthSellCustomAmount(ctx, userId, text, userState.tokenAddress);
        break;
        
      default:
        // Unknown state, clear it
        userStates.delete(userId);
        await ctx.reply(
          'âŒ Session expired. Please try again.',
          {
            reply_markup: {
              inline_keyboard: [[
                { text: 'ğŸ  Main Menu', callback_data: 'main_menu' }
              ]]
            }
          }
        );
        break;
    }
  } catch (error) {
    console.log('Error in message handler:', error);
    userStates.delete(userId);
    await ctx.reply(
      `âŒ An error occurred: ${error.message}\n\nPlease try again.`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ  Main Menu', callback_data: 'main_menu' }
          ]]
        }
      }
    );
  }
});
```

#### **5.2 SOL Message Processing Functions**
```javascript
// REQUIRED: Missing SOL message processing functions

async function handleSolPrivateKeyImport(ctx, userId, privateKey) {
  try {
    // Validate private key format
    if (!privateKey || privateKey.length < 32) {
      await ctx.reply(
        'âŒ **Invalid private key format**\n\nSOL private keys should be:\nâ€¢ Base58 format (88 characters)\nâ€¢ JSON array format [1,2,3...]\nâ€¢ Hex format (64+ characters)\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // For demo: mock validation
    // For production: validate with Solana Web3.js
    const isValid = privateKey.length > 32; // Simple validation

    if (!isValid) {
      await ctx.reply(
        'âŒ **Invalid Solana private key**\n\nPlease check the format and try again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Store encrypted wallet (mock for demo)
    const userData = await loadUserData(userId);
    userData.solWallets = userData.solWallets || [];
    
    // For production: encrypt private key with AES-256
    const walletData = {
      address: 'DEMO_SOL_ADDRESS_' + Date.now(),
      encryptedKey: 'ENCRYPTED_' + privateKey.slice(0, 10),
      imported: Date.now(),
      label: `SOL Wallet ${userData.solWallets.length + 1}`
    };
    
    userData.solWallets.push(walletData);
    userData.activeSolWallet = userData.solWallets.length - 1;
    
    await saveUserData(userId, userData);

    // Clear state and show success
    userStates.delete(userId);

    await ctx.reply(
      `âœ… **SOL Wallet Imported Successfully!**\n\n**Address:** ${walletData.address}\n**Label:** ${walletData.label}\n\nğŸŸ£ Your Solana wallet is ready for trading!`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ’° Buy Tokens', callback_data: 'sol_buy' }],
            [{ text: 'ğŸŸ£ SOL Wallet', callback_data: 'sol_wallet' }],
            [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );

    console.log(`âœ… SOL wallet imported for user ${userId}`);

  } catch (error) {
    console.log('Error importing SOL wallet:', error);
    userStates.delete(userId);
    await ctx.reply(
      `âŒ **Wallet import failed**\n\n${error.message}\n\nPlease try again.`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”„ Try Again', callback_data: 'import_sol_wallet' }
          ]]
        },
        parse_mode: 'Markdown'
      }
    );
  }
}

async function handleSolTokenAddress(ctx, userId, tokenAddress) {
  try {
    // Validate token address format
    const cleaned = tokenAddress.trim();
    
    if (!cleaned || cleaned.length !== 44) {
      await ctx.reply(
        'âŒ **Invalid token address**\n\nSOL token addresses should be:\nâ€¢ Exactly 44 characters\nâ€¢ Base58 format\nâ€¢ Example: DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // For production: validate with Solana Web3.js
    const isValidBase58 = /^[1-9A-HJ-NP-Za-km-z]{44}$/.test(cleaned);
    
    if (!isValidBase58) {
      await ctx.reply(
        'âŒ **Invalid Base58 format**\n\nPlease enter a valid SPL token mint address.\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Clear state and proceed to amount selection
    userStates.delete(userId);
    await showSolBuyAmountSelection(ctx, cleaned);

    console.log(`âœ… SOL token address processed: ${cleaned} for user ${userId}`);

  } catch (error) {
    console.log('Error processing SOL token address:', error);
    userStates.delete(userId);
    await ctx.reply(
      `âŒ **Error processing token address**\n\n${error.message}`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”„ Try Again', callback_data: 'sol_buy' }
          ]]
        }
      }
    );
  }
}

async function handleSolCustomAmount(ctx, userId, amountText, tokenAddress) {
  try {
    const amount = parseFloat(amountText.trim());
    
    // Validate amount
    if (isNaN(amount) || amount <= 0) {
      await ctx.reply(
        'âŒ **Invalid amount**\n\nPlease enter a valid number:\nâ€¢ Example: 0.5\nâ€¢ Minimum: 0.01 SOL\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    if (amount < 0.01) {
      await ctx.reply(
        'âŒ **Amount too small**\n\nMinimum amount: 0.01 SOL\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    if (amount > 1000) {
      await ctx.reply(
        'âŒ **Amount too large**\n\nMaximum amount: 1000 SOL\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Clear state and proceed to review
    userStates.delete(userId);
    await showSolBuyReview(ctx, tokenAddress, amount.toString());

    console.log(`âœ… SOL custom amount processed: ${amount} for user ${userId}`);

  } catch (error) {
    console.log('Error processing SOL custom amount:', error);
    userStates.delete(userId);
    await ctx.reply(
      `âŒ **Error processing amount**\n\n${error.message}`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”„ Try Again', callback_data: `sol_buy_custom_${tokenAddress}` }
          ]]
        }
      }
    );
  }
}

async function handleSolSellCustomAmount(ctx, userId, amountText, tokenAddress) {
  try {
    const amount = parseFloat(amountText.trim());
    
    // Validate amount
    if (isNaN(amount) || amount <= 0) {
      await ctx.reply(
        'âŒ **Invalid amount**\n\nPlease enter a valid number of tokens:\nâ€¢ Example: 100.5\nâ€¢ Must be positive\n\nTry again:',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // For demo: assume user has 1000 tokens
    const userBalance = 1000;
    
    if (amount > userBalance) {
      await ctx.reply(
        `âŒ **Insufficient balance**\n\nYou have: ${userBalance} tokens\nYou tried to sell: ${amount} tokens\n\nTry again:`,
        { parse_mode: 'Markdown' }
      );
      return;
    }

    // Clear state and proceed to review
    userStates.delete(userId);
    await showSolSellReview(ctx, tokenAddress, amount.toString());

    console.log(`âœ… SOL sell custom amount processed: ${amount} for user ${userId}`);

  } catch (error) {
    console.log('Error processing SOL sell custom amount:', error);
    userStates.delete(userId);
    await ctx.reply(
      `âŒ **Error processing amount**\n\n${error.message}`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”„ Try Again', callback_data: `sol_sell_custom_${tokenAddress}` }
          ]]
        }
      }
    );
  }
}
```

### **6. MISSING CORE FUNCTIONS IMPLEMENTATION**

#### **6.1 SOL Buy Review Function**
```javascript
// REQUIRED: Missing showSolBuyReview function
async function showSolBuyReview(ctx, tokenMint, amount) {
  const userId = ctx.from.id.toString();
  
  try {
    const userData = await loadUserData(userId);
    
    // Calculate fees and amounts
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const feeCalculation = solChain.calculateFee(amount, feePercent);
    
    // Get quote from Jupiter (mock for demo)
    const quote = {
      amountOut: '1000.5',
      priceImpact: '0.12',
      route: 'SOL â†’ USDC â†’ TOKEN'
    };

    const keyboard = [
      [{ text: 'âœ… Confirm Purchase', callback_data: `sol_buy_execute_${tokenMint}_${amount}` }],
      [{ text: 'ğŸ”™ Change Amount', callback_data: `sol_buy_retry_${tokenMint}` }],
      [{ text: 'âŒ Cancel', callback_data: 'chain_sol' }]
    ];

    await ctx.editMessageText(
      `ğŸŸ£ **CONFIRM SOL PURCHASE**

**Token:** ${tokenMint.slice(0, 8)}...${tokenMint.slice(-4)}

**Purchase Details:**
ğŸ’° SOL Amount: ${amount} SOL
ğŸ“ˆ Tokens Expected: ~${parseFloat(quote.amountOut).toLocaleString()}
ğŸ’¸ Service Fee: ${feeCalculation.feeAmount} SOL (${feePercent}%)
ğŸ’ Net Trade Amount: ${feeCalculation.netAmount} SOL

**Route:** ${quote.route}
**Price Impact:** ${quote.priceImpact}%

**Total Cost:** ${amount} SOL

âš ï¸ **Important**: This will execute immediately!
ğŸ”¥ **Fee Collection**: Automatic treasury transfer`,
      {
        reply_markup: { inline_keyboard: keyboard },
        parse_mode: 'Markdown'
      }
    );

  } catch (error) {
    console.log('Error showing SOL buy review:', error);
    await ctx.editMessageText(
      `âŒ **Error getting swap quote**

${error.message}

**Possible Issues:**
â€¢ Network connectivity
â€¢ Invalid token address
â€¢ Insufficient liquidity
â€¢ Jupiter API issues

Please try a different amount or token.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Again', callback_data: `sol_buy_retry_${tokenMint}` }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
  }
}
```

#### **6.2 SOL Sell Review Function**
```javascript
// REQUIRED: Missing showSolSellReview function
async function showSolSellReview(ctx, tokenMint, percentageOrAmount) {
  const userId = ctx.from.id.toString();
  
  try {
    const userData = await loadUserData(userId);
    
    // Determine if percentage or custom amount
    const isPercentage = Number.isInteger(parseFloat(percentageOrAmount)) && parseFloat(percentageOrAmount) <= 100;
    const mockBalance = 1000; // Demo token balance
    
    const sellAmount = isPercentage ? 
      (mockBalance * parseFloat(percentageOrAmount) / 100) : 
      parseFloat(percentageOrAmount);
    
    // Get quote from Jupiter (mock for demo)
    const quote = {
      solOut: (sellAmount * 0.0025).toFixed(6), // Mock conversion rate
      priceImpact: '0.15',
      route: 'TOKEN â†’ USDC â†’ SOL'
    };
    
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const solReceived = parseFloat(quote.solOut);
    const feeCalculation = solChain.calculateFee(solReceived, feePercent);

    const displayType = isPercentage ? `${percentageOrAmount}%` : `${sellAmount} tokens`;

    const keyboard = [
      [{ text: 'âœ… Confirm Sale', callback_data: `sol_sell_execute_${tokenMint}_${percentageOrAmount}` }],
      [{ text: 'ğŸ”™ Change Amount', callback_data: `sol_sell_token_${tokenMint}` }],
      [{ text: 'âŒ Cancel', callback_data: 'sol_sell' }]
    ];

    await ctx.editMessageText(
      `ğŸŸ£ **CONFIRM SOL SALE**

**Token:** ${tokenMint.slice(0, 8)}...${tokenMint.slice(-4)}

**Sale Details:**
ğŸ“ˆ Selling: ${sellAmount.toLocaleString()} tokens (${displayType})
ğŸ’° SOL Expected: ${solReceived.toFixed(6)} SOL
ğŸ’¸ Service Fee: ${feeCalculation.feeAmount} SOL (${feePercent}%)
ğŸ’ Net SOL Received: ${feeCalculation.netAmount} SOL

**Route:** ${quote.route}
**Price Impact:** ${quote.priceImpact}%

âš ï¸ **Important**: This will execute immediately!
ğŸ”¥ **Fee Collection**: Automatic treasury transfer

**Your remaining tokens:** ${(mockBalance - sellAmount).toLocaleString()}`,
      {
        reply_markup: { inline_keyboard: keyboard },
        parse_mode: 'Markdown'
      }
    );

  } catch (error) {
    console.log('Error showing SOL sell review:', error);
    await ctx.editMessageText(
      `âŒ **Error getting sell quote**

${error.message}

**Possible Issues:**
â€¢ Network connectivity
â€¢ Insufficient token balance
â€¢ Low liquidity
â€¢ Jupiter API issues

Please try a different amount.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'ğŸ”„ Try Again', callback_data: `sol_sell_token_${tokenMint}` }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
  }
}
```

### **7. SNIPE & MIRROR PLACEHOLDER FIXES**

#### **7.1 SOL Snipe Configuration**
```javascript
// REQUIRED: Missing showSolSnipeConfiguration function
async function showSolSnipeConfiguration(ctx, userData) {
  try {
    const snipeConfig = userData.solSnipeConfig || {
      enabled: false,
      strategy: 'new_pairs',
      amount: '0.1',
      slippage: 15,
      maxGasPrice: 0.01 // SOL units
    };

    const keyboard = [
      [
        { text: snipeConfig.enabled ? 'ğŸ”´ Stop Sniping' : 'ğŸŸ¢ Start Sniping', 
          callback_data: snipeConfig.enabled ? 'sol_snipe_stop' : 'sol_snipe_start' }
      ],
      [
        { text: 'âš™ï¸ Configure Strategy', callback_data: 'sol_snipe_config_strategy' },
        { text: 'ğŸ’° Set Amount', callback_data: 'sol_snipe_config_amount' }
      ],
      [
        { text: 'ğŸ“Š Snipe History', callback_data: 'sol_snipe_history' },
        { text: 'ğŸ¯ Active Targets', callback_data: 'sol_snipe_targets' }
      ],
      [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
    ];

    const statusText = snipeConfig.enabled ? 
      'ğŸŸ¢ **ACTIVE** - Monitoring for opportunities' : 
      'ğŸ”´ **INACTIVE** - Configure and start sniping';

    await ctx.editMessageText(
      `ğŸŸ£ **SOL SNIPE CONFIGURATION**

**Status:** ${statusText}

**Current Settings:**
ğŸ¯ Strategy: ${snipeConfig.strategy.replace('_', ' ').toUpperCase()}
ğŸ’° Amount per Snipe: ${snipeConfig.amount} SOL
ğŸšï¸ Slippage: ${snipeConfig.slippage}%
â›½ Max Gas: ${snipeConfig.maxGasPrice} SOL

**ğŸš§ SOL Sniping Coming Soon!**
Currently in development. ETH sniping is available now.

ğŸ’¡ **Preview Features:**
â€¢ Jupiter DEX monitoring
â€¢ New pair detection
â€¢ Pump.fun integration
â€¢ Cross-DEX arbitrage`,
      {
        reply_markup: { inline_keyboard: keyboard },
        parse_mode: 'Markdown'
      }
    );

  } catch (error) {
    console.log('Error showing SOL snipe configuration:', error);
    await ctx.editMessageText(
      `âŒ **Error loading snipe configuration**

${error.message}

Please try again.`,
      {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }
          ]]
        }
      }
    );
  }
}
```

#### **7.2 SOL Placeholder Handlers Update**
```javascript
// REQUIRED: Update SOL placeholder handlers with better UX

bot.action('sol_snipe', async (ctx) => {
  const userId = ctx.from.id.toString();
  const userData = await loadUserData(userId);

  // Check if user has SOL wallet
  if (!userData.solWallets || userData.solWallets.length === 0) {
    await ctx.editMessageText(
      `ğŸŸ£ **SOL SNIPE TOKEN**

âŒ No SOL wallet found. Import a wallet first to start sniping.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'â• Import SOL Wallet', callback_data: 'import_sol_wallet' }],
            [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
          ]
        }
      }
    );
    return;
  }

  await showSolSnipeConfiguration(ctx, userData);
});

bot.action('sol_mirror', async (ctx) => {
  await ctx.editMessageText(
    `ğŸŸ£ **SOL MIRROR TRADING**

ğŸš§ **Coming Soon in v1.1!**

**Planned Features:**
â€¢ Mirror successful Solana traders
â€¢ Auto-copy trades with customizable amounts
â€¢ Risk management controls
â€¢ Portfolio tracking
â€¢ Performance analytics

**Current Status:** In Development
**Expected Release:** Q2 2025

ğŸ’¡ **Available Now:** ETH mirror trading is fully functional!`,
    {
      reply_markup: {
        inline_keyboard: [
          [{ text: 'ğŸŸ  Try ETH Mirror', callback_data: 'eth_mirror' }],
          [{ text: 'ğŸ”” Get Notified', callback_data: 'sol_mirror_notify' }],
          [{ text: 'ğŸ”™ Back to SOL Menu', callback_data: 'chain_sol' }]
        ]
      },
      parse_mode: 'Markdown'
    }
  );
});

// Add notification handler
bot.action('sol_mirror_notify', async (ctx) => {
  await ctx.answerCbQuery('ğŸ”” You\'ll be notified when SOL mirror trading launches!');
  
  // In production: store user for notification list
  console.log(`User ${ctx.from.id} wants SOL mirror notifications`);
});
```

### **8. ERROR HANDLING & CLEANUP**

#### **8.1 Enhanced Error Handler**
```javascript
// REQUIRED: Better callback query error handling
bot.on('callback_query', async (ctx, next) => {
  try {
    await next();
  } catch (error) {
    console.log(`Callback query error [${ctx.callbackQuery.data}]:`, error);

    try {
      await ctx.answerCbQuery('âŒ An error occurred. Please try again.');
      
      // Determine appropriate fallback menu
      const callbackData = ctx.callbackQuery.data;
      let fallbackMenu = 'main_menu';
      
      if (callbackData.startsWith('sol_')) {
        fallbackMenu = 'chain_sol';
      } else if (callbackData.startsWith('eth_')) {
        fallbackMenu = 'chain_eth';
      }
      
      await ctx.editMessageText(
        `âŒ **Something went wrong**

**Error:** ${error.message}

**What happened:** The action "${callbackData}" failed
**Solution:** Try again or return to the main menu

**Troubleshooting:**
â€¢ Check your internet connection
â€¢ Try refreshing by returning to menu
â€¢ Contact support if error persists`,
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ğŸ”„ Try Again', callback_data: callbackData }],
              [{ text: 'ğŸ  Main Menu', callback_data: 'main_menu' }],
              [{ text: 'ğŸ”™ Go Back', callback_data: fallbackMenu }]
            ]
          },
          parse_mode: 'Markdown'
        }
      );
    } catch (editError) {
      // If we can't edit, send a new message
      console.log('Failed to edit error message, sending new one:', editError);
      await ctx.reply(
        `âŒ **Error occurred**\n\n${error.message}\n\nPlease return to the main menu.`,
        {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ  Main Menu', callback_data: 'main_menu' }
            ]]
          },
          parse_mode: 'Markdown'
        }
      );
    }
  }
});
```

#### **8.2 State Cleanup Enhancement**
```javascript
// REQUIRED: Enhanced state cleanup with logging
setInterval(() => {
  const now = Date.now();
  const oneHour = 60 * 60 * 1000;
  let cleanedCount = 0;

  for (const [userId, state] of userStates.entries()) {
    if (now - state.timestamp > oneHour) {
      console.log(`Cleaning expired state for user ${userId}: ${state.action}`);
      userStates.delete(userId);
      cleanedCount++;
    }
  }

  if (cleanedCount > 0) {
    console.log(`ğŸ§¹ Cleaned ${cleanedCount} expired user states`);
  }
  
  console.log(`ğŸ“Š Active user states: ${userStates.size}`);
}, 60 * 60 * 1000); // Run every hour
```

---

## ğŸ§ª **Testing & Validation Requirements**

### **Critical Test Cases**
1. **Startup Test**: Bot starts without errors and validates environment
2. **Menu Navigation**: All buttons work and lead to correct menus
3. **SOL Import**: Can import SOL wallet without crashes
4. **SOL Buy Flow**: Complete flow from token address to execution
5. **SOL Sell Flow**: Complete flow from holdings to execution
6. **Message Processing**: All text inputs are handled correctly
7. **Error Recovery**: Bot recovers gracefully from all error scenarios

### **Manual Test Script**
```
1. Start bot â†’ Should show main menu
2. Click "ğŸŸ£ SOL Chain" â†’ Should show SOL menu
3. Click "ğŸŸ£ SOL Wallet" â†’ Should prompt for wallet import
4. Click "â• Import Wallet" â†’ Should ask for private key
5. Send "test_private_key_demo" â†’ Should confirm import
6. Click "ğŸ’° Buy Token" â†’ Should ask for token address
7. Send "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" â†’ Should show amounts
8. Click "ğŸ’ 0.1 SOL" â†’ Should show review
9. Click "âœ… Confirm Purchase" â†’ Should execute (mock)
10. Click "ğŸ“ˆ Sell Token" â†’ Should show holdings
11. Test all error scenarios by sending invalid inputs
```

---

## ğŸš€ **Deployment Requirements**

### **Environment Variables**
```env
# Required
BOT_TOKEN=your_telegram_bot_token
ETH_RPC_URL=your_ethereum_rpc_url
TREASURY_WALLET=your_fee_collection_wallet

# Optional but recommended
SOL_RPC_URL=your_solana_rpc_url
ENCRYPTION_KEY=your_32_byte_encryption_key
NODE_ENV=production
```

### **Production Checklist**
- [ ] All missing functions implemented
- [ ] All callback handlers working
- [ ] Message processing complete
- [ ] Error handling robust
- [ ] Environment validation working
- [ ] Mock services ready for blockchain integration
- [ ] Logging comprehensive
- [ ] Rate limiting active
- [ ] State management stable

---

## ğŸ“ˆ **Success Metrics**

### **Phase 1 Success**: Core Stability âœ…
- Bot starts without errors
- All menus accessible via buttons
- No crashes on SOL interactions
- Environment validation working

### **Phase 2 Success**: SOL Functionality âœ…
- SOL wallet import works
- SOL buy flow complete end-to-end
- SOL sell flow complete end-to-end
- All message inputs handled

### **Phase 3 Success**: Production Ready âœ…
- 24 hours uptime without crashes
- All error scenarios handled gracefully
- User state management stable
- Ready for real blockchain integration

---

## ğŸ¯ **Implementation Priority**

1. **ğŸš¨ CRITICAL (Fix First)**
   - Single working `startBot()` function
   - Environment validation
   - Missing SOL callback handlers

2. **ğŸ”¥ HIGH (Fix Second)**
   - Message processing system
   - SOL utility functions
   - Error handling

3. **âš¡ MEDIUM (Fix Third)**
   - Enhanced UX messages
   - Better error recovery
   - State cleanup

4. **ğŸ’¡ LOW (Polish)**
   - Snipe configuration UI
   - Advanced error reporting
   - Performance optimization

---

**ğŸ¯ GOAL**: A rock-solid bot that never crashes and handles all user interactions gracefully, ready for real blockchain integration in the next phase.