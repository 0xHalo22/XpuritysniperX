// ====================================================================
// PURITY SNIPER BOT - COMPLETE SNIPING ENGINE
// 3-Strategy System: Degen Mode, Targeted Liquidity, Contract Methods
// ====================================================================

const { ethers } = require('ethers');
const winston = require('winston');

// ====================================================================
// SNIPING ENGINE - DATA STRUCTURES & STATE MANAGEMENT
// ====================================================================

// Default sniping configuration for new users
const defaultSnipeConfig = {
  active: false,
  amount: 0.1,           // ETH amount to snipe with
  slippage: 10,          // Higher slippage for speed (10%)
  strategy: 'first_liquidity', // 'new_pairs', 'first_liquidity', 'contract_methods'
  maxGasPrice: 100,      // Max gwei for snipe attempts
  minLiquidity: 1,       // Minimum ETH liquidity required
  maxSnipesPerHour: 5,   // Max snipes per hour
  createdAt: Date.now(),

  // Target tokens for pre-launch sniping
  targetTokens: [] // Array of { address, strategy, method?, label?, status, addedAt }
};

// Active snipe monitors - tracks WebSocket listeners per user
const activeSnipeMonitors = new Map(); // userId -> { provider, filter, handler }

// Snipe attempt tracking for rate limiting
const snipeAttempts = new Map(); // userId -> { attempts: [], hourlyCount: 0 }

// Helper function to check snipe rate limits
function checkSnipeRateLimit(userId, maxPerHour = 5) {
  const now = Date.now();
  const oneHour = 60 * 60 * 1000;

  if (!snipeAttempts.has(userId)) {
    snipeAttempts.set(userId, { attempts: [], hourlyCount: 0 });
  }

  const userAttempts = snipeAttempts.get(userId);

  // Clean old attempts (older than 1 hour)
  userAttempts.attempts = userAttempts.attempts.filter(time => now - time < oneHour);
  userAttempts.hourlyCount = userAttempts.attempts.length;

  if (userAttempts.hourlyCount >= maxPerHour) {
    throw new Error(`Snipe rate limit exceeded. Max ${maxPerHour} snipes per hour.`);
  }

  // Add current attempt
  userAttempts.attempts.push(now);
  userAttempts.hourlyCount++;

  console.log(`âœ… Snipe rate check passed: ${userAttempts.hourlyCount}/${maxPerHour} this hour`);
}

// ====================================================================
// SNIPING ENGINE - CORE EXECUTION FUNCTION
// ====================================================================

async function executeSnipeBuy(userId, tokenAddress, ethAmount, triggerTx = null) {
  try {
    console.log(`ðŸŽ¯ EXECUTING SNIPE BUY for user ${userId}`);
    console.log(`   Token: ${tokenAddress}`);
    console.log(`   Amount: ${ethAmount} ETH`);
    console.log(`   Trigger: ${triggerTx || 'Manual'}`);

    // Check rate limits
    checkSnipeRateLimit(userId);

    // Load user data and wallet
    const userData = await loadUserData(userId);
    if (!userData.ethWallets || userData.ethWallets.length === 0) {
      throw new Error('No ETH wallet found for sniping');
    }

    const activeWalletIndex = userData.activeEthWallet || 0;
    const encryptedKey = userData.ethWallets[activeWalletIndex];
    const privateKey = await walletManager.decryptPrivateKey(encryptedKey, userId);

    // Calculate fee (1% for standard users, 0.5% for premium)
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const feeCalculation = ethChain.calculateFee(ethAmount, feePercent);

    console.log(`ðŸ’° Snipe fee calculation: ${feeCalculation.feeAmount} ETH (${feePercent}%)`);

    // Execute the buy transaction with higher gas for speed
    const snipeConfig = userData.snipeConfig || defaultSnipeConfig;
    const gasMultiplier = 1.5; // 50% higher gas for faster execution
    
    const buyResult = await ethChain.executeTokenBuy(
      tokenAddress,
      feeCalculation.netAmount, // Use net amount after fee
      privateKey,
      snipeConfig.slippage,
      gasMultiplier
    );

    console.log(`âœ… Snipe buy executed: ${buyResult.hash}`);

    // Attempt fee collection (non-blocking)
    try {
      const feeResult = await ethChain.sendFeeToTreasury(
        privateKey,
        feeCalculation.feeAmount
      );
      console.log(`ðŸ’° Snipe fee collected: ${feeResult?.hash || 'Fee collection attempted'}`);
    } catch (feeError) {
      console.log(`âš ï¸ Snipe fee collection failed (non-blocking): ${feeError.message}`);
    }

    // Record successful snipe transaction
    const transactionData = {
      id: `snipe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'snipe',
      status: 'completed',
      chain: 'ethereum',
      hash: buyResult.hash,
      tokenIn: ethChain.contracts.WETH,
      tokenOut: tokenAddress,
      amountIn: ethAmount,
      amountOut: buyResult.amountOut || 'unknown',
      fee: feeCalculation.feeAmount,
      feePercent: feePercent,
      gasUsed: buyResult.gasUsed || 'unknown',
      gasPrice: buyResult.gasPrice || 'unknown',
      timestamp: Date.now(),
      strategy: snipeConfig.strategy,
      triggerTx: triggerTx,
      autoExecuted: true,
      slippage: snipeConfig.slippage
    };

    await recordTransaction(userId, transactionData);

    // Notify user of successful snipe
    try {
      const tokenDisplay = tokenAddress.slice(0, 8) + '...';
      await bot.telegram.sendMessage(
        userId,
        `ðŸ”¥ **SNIPE SUCCESSFUL!**\n\n` +
        `**Token:** ${tokenDisplay}\n` +
        `**Amount:** ${ethAmount} ETH\n` +
        `**Strategy:** ${getStrategyDisplayName(snipeConfig.strategy)}\n` +
        `**TX:** ${buyResult.hash.slice(0, 10)}...\n\n` +
        `âœ… Fee collected: ${feeCalculation.feeAmount} ETH`,
        { parse_mode: 'Markdown' }
      );
    } catch (notifyError) {
      console.log(`âš ï¸ Failed to notify user of successful snipe: ${notifyError.message}`);
    }

    console.log(`ðŸŽ‰ SNIPE COMPLETED SUCCESSFULLY for user ${userId}`);
    return buyResult;

  } catch (error) {
    console.log(`âŒ SNIPE FAILED for user ${userId}: ${error.message}`);

    // Record failed snipe attempt
    const transactionData = {
      id: `snipe_failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'snipe',
      status: 'failed',
      chain: 'ethereum',
      tokenOut: tokenAddress,
      amountIn: ethAmount,
      error: error.message,
      timestamp: Date.now(),
      strategy: (await loadUserData(userId)).snipeConfig?.strategy || 'unknown',
      triggerTx: triggerTx,
      autoExecuted: true
    };

    try {
      await recordTransaction(userId, transactionData);
    } catch (recordError) {
      console.log(`âš ï¸ Failed to record failed snipe: ${recordError.message}`);
    }

    // Notify user of failed snipe
    try {
      const tokenDisplay = tokenAddress.slice(0, 8) + '...';
      await bot.telegram.sendMessage(
        userId,
        `âŒ **SNIPE FAILED**\n\n` +
        `**Token:** ${tokenDisplay}\n` +
        `**Reason:** ${error.message.slice(0, 100)}...\n` +
        `**Amount:** ${ethAmount} ETH`,
        { parse_mode: 'Markdown' }
      );
    } catch (notifyError) {
      console.log(`âš ï¸ Failed to notify user of failed snipe: ${notifyError.message}`);
    }

    throw error;
  }
}

// ====================================================================
// STRATEGY 1: DEGEN MODE - Monitor ALL New Pairs
// ====================================================================

async function startDegenModeMonitoring(userId) {
  try {
    const userData = await loadUserData(userId);
    const snipeConfig = userData.snipeConfig;

    console.log(`ðŸš¨ Starting DEGEN MODE monitoring for user ${userId} - will snipe ALL new pairs!`);

    // Get WebSocket provider for real-time monitoring
    const provider = await ethChain.getProvider();

    // Uniswap V2 Factory Contract Address
    const uniswapV2Factory = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';

    // PairCreated event topic
    const pairCreatedTopic = '0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31aaaffd8d4';

    // Create event filter for new pair creation
    const filter = {
      address: uniswapV2Factory,
      topics: [pairCreatedTopic]
    };

    // Event handler function
    const eventHandler = async (log) => {
      try {
        console.log(`ðŸ”¥ NEW PAIR DETECTED for user ${userId}! TX: ${log.transactionHash}`);

        // Parse the PairCreated event
        const abiDecoder = new ethers.utils.Interface([
          'event PairCreated(address indexed token0, address indexed token1, address pair, uint256)'
        ]);

        const decoded = abiDecoder.parseLog(log);
        const token0 = decoded.args.token0;
        const token1 = decoded.args.token1;
        const pairAddress = decoded.args.pair;

        console.log(`ðŸ“Š Pair details: Token0=${token0}, Token1=${token1}, Pair=${pairAddress}`);

        // Determine which token is the new one (not WETH)
        const wethAddress = ethChain.contracts.WETH.toLowerCase();
        let newTokenAddress;

        if (token0.toLowerCase() === wethAddress) {
          newTokenAddress = token1;
        } else if (token1.toLowerCase() === wethAddress) {
          newTokenAddress = token0;
        } else {
          console.log(`âš ï¸ Neither token is WETH, skipping pair: ${token0}, ${token1}`);
          return;
        }

        console.log(`ðŸŽ¯ Target token identified: ${newTokenAddress}`);

        // Execute snipe attempt
        await executeSnipeBuy(userId, newTokenAddress, snipeConfig.amount, log.transactionHash);

      } catch (error) {
        console.log(`âŒ Error processing pair creation event for user ${userId}:`, error.message);
      }
    };

    // Start listening for events
    provider.on(filter, eventHandler);

    // Store monitor reference for cleanup
    activeSnipeMonitors.set(userId, { 
      provider, 
      filter, 
      handler: eventHandler,
      startTime: Date.now(),
      strategy: 'new_pairs',
      mode: 'degen'
    });

    console.log(`âœ… DEGEN MODE monitoring started for user ${userId} - monitoring ALL new pairs`);

  } catch (error) {
    console.log(`âŒ Failed to start degen mode monitoring for user ${userId}:`, error.message);
    throw error;
  }
}

// ====================================================================
// STRATEGY 2: TARGETED LIQUIDITY - Monitor Specific Tokens
// ====================================================================

async function startTargetedLiquidityMonitoring(userId) {
  try {
    const userData = await loadUserData(userId);
    const snipeConfig = userData.snipeConfig;
    const targetTokens = snipeConfig.targetTokens?.filter(
      t => t.strategy === 'first_liquidity' && t.status === 'waiting'
    ) || [];

    if (targetTokens.length === 0) {
      throw new Error('No target tokens configured for liquidity monitoring');
    }

    console.log(`ðŸ’§ Starting targeted liquidity monitoring for user ${userId} - ${targetTokens.length} tokens`);

    const provider = await ethChain.getProvider();
    const uniswapV2Factory = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';
    const pairCreatedTopic = '0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31aaaffd8d4';

    const filter = {
      address: uniswapV2Factory,
      topics: [pairCreatedTopic]
    };

    const eventHandler = async (log) => {
      try {
        // Parse event to get token addresses
        const abiDecoder = new ethers.utils.Interface([
          'event PairCreated(address indexed token0, address indexed token1, address pair, uint256)'
        ]);

        const decoded = abiDecoder.parseLog(log);
        const token0 = decoded.args.token0.toLowerCase();
        const token1 = decoded.args.token1.toLowerCase();

        console.log(`ðŸ” Checking pair: ${token0} / ${token1}`);

        // Check if any of our target tokens are in this pair
        const matchedToken = targetTokens.find(target => 
          target.address.toLowerCase() === token0 || target.address.toLowerCase() === token1
        );

        if (matchedToken) {
          console.log(`ðŸŽ¯ TARGET TOKEN LIQUIDITY DETECTED! ${matchedToken.address}`);

          // Execute snipe for this specific token
          await executeSnipeBuy(userId, matchedToken.address, snipeConfig.amount, log.transactionHash);

          // Update token status in database
          const currentUserData = await loadUserData(userId);
          const tokenToUpdate = currentUserData.snipeConfig.targetTokens.find(
            t => t.address === matchedToken.address && t.strategy === 'first_liquidity'
          );

          if (tokenToUpdate) {
            tokenToUpdate.status = 'sniped';
            tokenToUpdate.snipedAt = Date.now();
            tokenToUpdate.txHash = log.transactionHash;
            await saveUserData(userId, currentUserData);
          }

          // Notify user
          try {
            const displayName = matchedToken.label || `Token ${matchedToken.address.slice(0, 8)}...`;
            await bot.telegram.sendMessage(
              userId,
              `ðŸ”¥ **TARGET TOKEN SNIPED!**\n\n${displayName} liquidity added and sniped!\n\n**TX:** ${log.transactionHash.slice(0, 10)}...`
            );
          } catch (notifyError) {
            console.log(`âš ï¸ Failed to notify user ${userId}:`, notifyError.message);
          }
        }

      } catch (error) {
        console.log(`âŒ Error processing liquidity event for user ${userId}:`, error.message);
      }
    };

    provider.on(filter, eventHandler);

    activeSnipeMonitors.set(userId, { 
      provider, 
      filter, 
      handler: eventHandler,
      startTime: Date.now(),
      strategy: 'first_liquidity',
      targetCount: targetTokens.length,
      mode: 'targeted_liquidity'
    });

    console.log(`âœ… Targeted liquidity monitoring started for ${targetTokens.length} tokens`);

  } catch (error) {
    console.log(`âŒ Failed to start targeted liquidity monitoring for user ${userId}:`, error.message);
    throw error;
  }
}

// ====================================================================
// STRATEGY 3: CONTRACT METHODS - Monitor Specific Method Calls
// ====================================================================

async function startMethodMonitoring(userId) {
  try {
    const userData = await loadUserData(userId);
    const snipeConfig = userData.snipeConfig;
    const targetTokens = snipeConfig.targetTokens?.filter(
      t => t.strategy === 'contract_methods' && t.status === 'waiting' && t.method
    ) || [];

    if (targetTokens.length === 0) {
      throw new Error('No method targets configured for monitoring');
    }

    console.log(`ðŸ”§ Starting method monitoring for user ${userId} - ${targetTokens.length} method targets`);

    const provider = await ethChain.getProvider();
    const eventHandlers = [];

    // Create filters for each token/method combination
    for (const target of targetTokens) {
      const filter = {
        address: target.address,
        topics: [target.method] // Method signature as topic
      };

      const eventHandler = async (log) => {
        try {
          console.log(`ðŸ”§ METHOD CALL DETECTED! Contract: ${target.address}, Method: ${target.method}`);

          // Execute snipe for this token
          await executeSnipeBuy(userId, target.address, snipeConfig.amount, log.transactionHash);

          // Update token status
          const currentUserData = await loadUserData(userId);
          const tokenToUpdate = currentUserData.snipeConfig.targetTokens.find(
            t => t.address === target.address && t.strategy === 'contract_methods' && t.method === target.method
          );

          if (tokenToUpdate) {
            tokenToUpdate.status = 'sniped';
            tokenToUpdate.snipedAt = Date.now();
            tokenToUpdate.txHash = log.transactionHash;
            await saveUserData(userId, currentUserData);
          }

          // Notify user
          try {
            const displayName = target.label || `Token ${target.address.slice(0, 8)}...`;
            await bot.telegram.sendMessage(
              userId,
              `ðŸ”¥ **METHOD CALL SNIPED!**\n\n${displayName} method ${target.method} executed and sniped!\n\n**TX:** ${log.transactionHash.slice(0, 10)}...`
            );
          } catch (notifyError) {
            console.log(`âš ï¸ Failed to notify user ${userId}:`, notifyError.message);
          }

        } catch (error) {
          console.log(`âŒ Error processing method call event:`, error.message);
        }
      };

      provider.on(filter, eventHandler);
      eventHandlers.push({ filter, handler: eventHandler });
    }

    // Store all filters and handlers for cleanup
    activeSnipeMonitors.set(userId, { 
      provider, 
      filters: eventHandlers, // Multiple filters for method monitoring
      startTime: Date.now(),
      strategy: 'contract_methods',
      targetCount: targetTokens.length,
      mode: 'method_targeted'
    });

    console.log(`âœ… Method monitoring started for ${targetTokens.length} method targets`);

  } catch (error) {
    console.log(`âŒ Failed to start method monitoring for user ${userId}:`, error.message);
    throw error;
  }
}

// ====================================================================
// MONITORING CONTROL FUNCTIONS
// ====================================================================

async function startSnipeMonitoring(userId) {
  try {
    const userData = await loadUserData(userId);
    const snipeConfig = userData.snipeConfig;

    if (activeSnipeMonitors.has(userId)) {
      console.log(`âš ï¸ Snipe monitoring already active for user ${userId}`);
      return;
    }

    console.log(`ðŸŽ¯ Starting snipe monitoring for user ${userId} with strategy: ${snipeConfig.strategy}`);

    // Route to appropriate monitoring strategy
    if (snipeConfig.strategy === 'new_pairs') {
      await startDegenModeMonitoring(userId);
    } else if (snipeConfig.strategy === 'first_liquidity') {
      await startTargetedLiquidityMonitoring(userId);
    } else if (snipeConfig.strategy === 'contract_methods') {
      await startMethodMonitoring(userId);
    } else {
      throw new Error(`Unknown strategy: ${snipeConfig.strategy}`);
    }

  } catch (error) {
    console.log(`âŒ Failed to start snipe monitoring for user ${userId}:`, error.message);
    throw error;
  }
}

async function stopSnipeMonitoring(userId) {
  try {
    if (!activeSnipeMonitors.has(userId)) {
      console.log(`âš ï¸ No active snipe monitoring found for user ${userId}`);
      return;
    }

    const monitor = activeSnipeMonitors.get(userId);

    // Handle different monitoring modes
    if (monitor.mode === 'method_targeted' && monitor.filters) {
      // Method monitoring has multiple filters
      for (const filterHandler of monitor.filters) {
        monitor.provider.off(filterHandler.filter, filterHandler.handler);
      }
      console.log(`ðŸ›‘ Stopped method monitoring for user ${userId} (${monitor.filters.length} targets)`);
    } else if (monitor.provider && monitor.filter && monitor.handler) {
      // Single filter monitoring (degen mode, targeted liquidity)
      monitor.provider.off(monitor.filter, monitor.handler);
      console.log(`ðŸ›‘ Stopped ${monitor.mode || monitor.strategy} monitoring for user ${userId}`);
    }

    // Remove from active monitors
    activeSnipeMonitors.delete(userId);

  } catch (error) {
    console.log(`âŒ Error stopping snipe monitoring for user ${userId}:`, error.message);
    throw error;
  }
}

function cleanupSnipeMonitors() {
  console.log(`ðŸ§¹ Cleaning up ${activeSnipeMonitors.size} active snipe monitors...`);

  for (const [userId, monitor] of activeSnipeMonitors.entries()) {
    try {
      if (monitor.mode === 'method_targeted' && monitor.filters) {
        // Method monitoring cleanup
        for (const filterHandler of monitor.filters) {
          monitor.provider.off(filterHandler.filter, filterHandler.handler);
        }
        console.log(`âœ… Cleaned up method monitoring for user ${userId}`);
      } else if (monitor.provider && monitor.filter && monitor.handler) {
        // Single filter cleanup
        monitor.provider.off(monitor.filter, monitor.handler);
        console.log(`âœ… Cleaned up ${monitor.mode || monitor.strategy} monitoring for user ${userId}`);
      }
    } catch (error) {
      console.log(`âš ï¸ Error cleaning up snipe monitor for user ${userId}:`, error.message);
    }
  }

  activeSnipeMonitors.clear();
  console.log(`âœ… All snipe monitors cleaned up`);
}

// ====================================================================
// HELPER FUNCTIONS
// ====================================================================

function getStrategyDisplayName(strategy) {
  const strategyNames = {
    'new_pairs': 'New Pairs (Degen Mode)',
    'first_liquidity': 'First Liquidity Events', 
    'contract_methods': 'Contract Methods'
  };
  return strategyNames[strategy] || 'Unknown Strategy';
}

async function getSnipeStatistics(userId) {
  try {
    const userData = await loadUserData(userId);
    const transactions = userData.transactions || [];

    const snipeTransactions = transactions.filter(tx => 
      tx.type === 'snipe' && tx.timestamp
    );

    const now = Date.now();
    const oneDayAgo = now - (24 * 60 * 60 * 1000);

    const todaySnipes = snipeTransactions.filter(tx => 
      tx.timestamp > oneDayAgo
    );

    const todaySuccessful = todaySnipes.filter(tx => 
      tx.status === 'completed' || tx.hash
    );

    const successRate = todaySnipes.length > 0 
      ? Math.round((todaySuccessful.length / todaySnipes.length) * 100)
      : 0;

    return {
      totalSnipes: snipeTransactions.length,
      todaySnipes: todaySnipes.length,
      todaySuccessful: todaySuccessful.length,
      successRate: successRate,
      strategies: {
        new_pairs: snipeTransactions.filter(tx => tx.strategy === 'new_pairs').length,
        first_liquidity: snipeTransactions.filter(tx => tx.strategy === 'first_liquidity').length,
        contract_methods: snipeTransactions.filter(tx => tx.strategy === 'contract_methods').length
      }
    };
  } catch (error) {
    console.log('Error getting snipe statistics:', error);
    return {
      totalSnipes: 0,
      todaySnipes: 0,
      todaySuccessful: 0,
      successRate: 0,
      strategies: { new_pairs: 0, first_liquidity: 0, contract_methods: 0 }
    };
  }
}

// ====================================================================
// EXPORTS
// ====================================================================

module.exports = {
  // Core Functions
  executeSnipeBuy,
  startSnipeMonitoring,
  stopSnipeMonitoring,
  
  // Strategy Functions
  startDegenModeMonitoring,
  startTargetedLiquidityMonitoring,
  startMethodMonitoring,
  
  // Utility Functions
  checkSnipeRateLimit,
  getSnipeStatistics,
  getStrategyDisplayName,
  cleanupSnipeMonitors,
  
  // Configuration
  defaultSnipeConfig,
  
  // State Maps (for monitoring)
  activeSnipeMonitors,
  snipeAttempts
};