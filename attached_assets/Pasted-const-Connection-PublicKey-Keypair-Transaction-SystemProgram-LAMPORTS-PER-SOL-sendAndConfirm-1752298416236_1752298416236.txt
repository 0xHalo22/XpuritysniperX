const { Connection, PublicKey, Keypair, Transaction, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction } = require('@solana/web3.js');
const { TOKEN_PROGRAM_ID, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, getAccount } = require('@solana/spl-token');
const bs58 = require('bs58');
const fetch = require('node-fetch');

class SolChain {
  constructor() {
    // Helius RPC connection with WebSocket support
    this.connection = new Connection(process.env.SOL_RPC_URL, {
      commitment: 'confirmed',
      wsEndpoint: process.env.SOL_RPC_WSS || process.env.SOL_RPC_URL?.replace('https://', 'wss://'),
      disableRetryOnRateLimit: false,
      confirmTransactionInitialTimeout: 30000
    });

    // Jupiter API for best swap routing
    this.jupiterAPI = 'https://quote-api.jup.ag/v6';

    // Native SOL mint address
    this.NATIVE_SOL = 'So11111111111111111111111111111111111111112';

    // Popular token mints for quick access
    this.tokens = {
      SOL: 'So11111111111111111111111111111111111111112',
      USDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      USDT: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB',
      RAY: '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R',
      BONK: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263'
    };

    console.log('✅ SOL Chain initialized with Helius integration');
    console.log(`🔗 RPC: ${process.env.SOL_RPC_URL?.substring(0, 50)}...`);
    console.log(`📡 WSS: ${process.env.SOL_RPC_WSS?.substring(0, 50)}...`);
  }

  /**
   * Test connection to Helius
   */
  async testConnection() {
    try {
      const slot = await this.connection.getSlot();
      const blockTime = await this.connection.getBlockTime(slot);
      console.log(`🟢 Helius connection successful - Slot: ${slot}, Block time: ${new Date(blockTime * 1000)}`);
      return true;
    } catch (error) {
      console.log(`🔴 Helius connection failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Get SOL balance for an address
   */
  async getBalance(address) {
    try {
      const publicKey = new PublicKey(address);
      const balance = await this.connection.getBalance(publicKey);
      return (balance / LAMPORTS_PER_SOL).toFixed(6);
    } catch (error) {
      throw new Error(`Failed to get SOL balance: ${error.message}`);
    }
  }

  /**
   * Get current priority fee from Helius
   */
  async getGasPrice() {
    try {
      const recentFees = await this.connection.getRecentPrioritizationFees();
      const fees = recentFees.map(fee => fee.prioritizationFee).sort((a, b) => a - b);
      const medianFee = fees[Math.floor(fees.length / 2)] || 1000;

      const baseFee = 5000;
      const priorityFee = Math.max(medianFee, 1000); // Minimum 1000 micro-lamports

      return {
        baseFee,
        priorityFee,
        totalFee: baseFee + priorityFee,
        formatted: {
          baseFeeSOL: (baseFee / LAMPORTS_PER_SOL).toFixed(9),
          priorityFeeSOL: (priorityFee / LAMPORTS_PER_SOL).toFixed(9),
          totalFeeSOL: ((baseFee + priorityFee) / LAMPORTS_PER_SOL).toFixed(9)
        }
      };
    } catch (error) {
      console.log(`⚠️ Failed to get priority fees: ${error.message}`);
      // Return default fees if API fails
      return {
        baseFee: 5000,
        priorityFee: 1000,
        totalFee: 6000,
        formatted: {
          baseFeeSOL: '0.000005000',
          priorityFeeSOL: '0.000001000',
          totalFeeSOL: '0.000006000'
        }
      };
    }
  }

  /**
   * Get token information using Helius DAS API
   */
  async getTokenInfo(mintAddress) {
    try {
      const mintPublicKey = new PublicKey(mintAddress);
      
      // Try Helius DAS API first for enhanced token data
      const heliusUrl = process.env.SOL_RPC_URL.split('?')[0]; // Remove query params
      const dasResponse = await fetch(`${heliusUrl}/v0/token-metadata`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          mintAccounts: [mintAddress],
          includeOffChain: true,
          disableCache: false
        })
      });

      if (dasResponse.ok) {
        const dasData = await dasResponse.json();
        if (dasData.length > 0) {
          const token = dasData[0];
          return {
            address: mintAddress,
            name: token.onChainMetadata?.metadata?.name || 'Unknown Token',
            symbol: token.onChainMetadata?.metadata?.symbol || 'UNKNOWN',
            decimals: token.onChainMetadata?.metadata?.decimals || 9,
            logoURI: token.offChainMetadata?.metadata?.image,
            verified: token.onChainMetadata?.metadata?.verified || false
          };
        }
      }

      // Fallback to standard RPC
      const mintInfo = await this.connection.getParsedAccountInfo(mintPublicKey);
      if (!mintInfo.value) {
        throw new Error('Token not found');
      }

      const decimals = mintInfo.value.data.parsed.info.decimals;
      return {
        address: mintAddress,
        name: 'Unknown Token',
        symbol: 'UNKNOWN',
        decimals: decimals,
        logoURI: null,
        verified: false
      };

    } catch (error) {
      throw new Error(`Failed to get token info: ${error.message}`);
    }
  }

  /**
   * Get Jupiter quote for token swap
   */
  async getQuote(inputMint, outputMint, amount, slippageBps = 300) {
    try {
      const url = `${this.jupiterAPI}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${slippageBps}`;
      
      const response = await fetch(url);
      const quote = await response.json();

      if (!response.ok) {
        throw new Error(quote.error || 'Failed to get quote');
      }

      return {
        inputMint: quote.inputMint,
        outputMint: quote.outputMint,
        inAmount: quote.inAmount,
        outAmount: quote.outAmount,
        otherAmountThreshold: quote.otherAmountThreshold,
        swapMode: quote.swapMode,
        slippageBps: quote.slippageBps,
        platformFee: quote.platformFee,
        priceImpactPct: quote.priceImpactPct,
        routePlan: quote.routePlan
      };
    } catch (error) {
      throw new Error(`Failed to get Jupiter quote: ${error.message}`);
    }
  }

  /**
   * Execute swap using Jupiter with Helius for fast settlement
   */
  async executeSwap(wallet, quote, feePercentage = 1.0) {
    try {
      console.log(`🔄 Executing SOL swap via Jupiter...`);

      // Get swap transaction from Jupiter
      const swapResponse = await fetch(`${this.jupiterAPI}/swap`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          quoteResponse: quote,
          userPublicKey: wallet.publicKey.toString(),
          wrapAndUnwrapSol: true,
          computeUnitPriceMicroLamports: 1000, // Priority fee
        })
      });

      const swapData = await swapResponse.json();
      if (!swapResponse.ok) {
        throw new Error(swapData.error || 'Failed to get swap transaction');
      }

      // Deserialize the transaction
      const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
      let transaction = Transaction.from(swapTransactionBuf);

      // Add fee collection if specified
      if (feePercentage > 0) {
        const feeAmount = Math.floor(parseInt(quote.outAmount) * (feePercentage / 100));
        if (feeAmount > 0 && process.env.TREASURY_WALLET_SOL) {
          try {
            const feeTransfer = SystemProgram.transfer({
              fromPubkey: wallet.publicKey,
              toPubkey: new PublicKey(process.env.TREASURY_WALLET_SOL),
              lamports: feeAmount
            });
            transaction.add(feeTransfer);
            console.log(`💰 Added ${feePercentage}% fee: ${feeAmount / LAMPORTS_PER_SOL} SOL`);
          } catch (feeError) {
            console.log(`⚠️ Fee collection failed, continuing with trade: ${feeError.message}`);
          }
        }
      }

      // Get recent blockhash from Helius
      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = wallet.publicKey;

      // Sign and send via Helius
      transaction.sign(wallet);
      
      const signature = await this.connection.sendRawTransaction(
        transaction.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
          maxRetries: 3
        }
      );

      console.log(`⏳ SOL swap submitted: ${signature}`);
      
      // Confirm transaction using Helius fast confirmation
      await this.confirmTransactionPolling(signature, 'confirmed', 30000);

      console.log(`✅ SOL swap completed: ${signature}`);
      return {
        signature,
        inputAmount: quote.inAmount,
        outputAmount: quote.outAmount,
        inputToken: quote.inputMint,
        outputToken: quote.outputMint
      };

    } catch (error) {
      console.log(`❌ SOL swap failed: ${error.message}`);
      throw new Error(`Swap execution failed: ${error.message}`);
    }
  }

  /**
   * Monitor account changes via Helius WebSocket
   */
  async startMirrorTrading(targetWallet, callback) {
    try {
      console.log(`🪞 Starting SOL mirror monitoring via Helius: ${targetWallet}`);
      
      const targetPublicKey = new PublicKey(targetWallet);
      
      // Subscribe to account changes via Helius WebSocket
      const subscriptionId = this.connection.onAccountChange(
        targetPublicKey,
        async (accountInfo) => {
          try {
            const tradeData = {
              wallet: targetWallet,
              lamports: accountInfo.lamports,
              timestamp: Date.now(),
              source: 'helius_account_change',
              slot: accountInfo.context.slot
            };
            await callback(tradeData);
          } catch (error) {
            console.log('SOL mirror callback error:', error.message);
          }
        },
        'confirmed'
      );

      console.log(`✅ Helius mirror monitoring active: ${targetWallet} (Subscription: ${subscriptionId})`);
      return subscriptionId;
    } catch (error) {
      throw new Error(`Failed to start SOL mirror trading: ${error.message}`);
    }
  }

  /**
   * Monitor program logs for new token creation (pump.fun, Raydium, etc.)
   */
  async startSniping(programId, callback) {
    try {
      console.log(`🎯 Starting SOL sniping via Helius: ${programId}`);
      
      const subscriptionId = this.connection.onLogs(
        new PublicKey(programId),
        async (logs) => {
          try {
            const snipeData = {
              signature: logs.signature,
              logs: logs.logs,
              timestamp: Date.now(),
              source: 'helius_program_logs',
              slot: logs.context.slot
            };
            await callback(snipeData);
          } catch (error) {
            console.log('SOL snipe callback error:', error.message);
          }
        },
        'confirmed'
      );

      console.log(`✅ Helius sniping active for program: ${programId} (Subscription: ${subscriptionId})`);
      return subscriptionId;
    } catch (error) {
      throw new Error(`Failed to start SOL sniping: ${error.message}`);
    }
  }

  /**
   * Confirm transaction using polling with Helius speed
   */
  async confirmTransactionPolling(signature, commitment = 'confirmed', timeout = 30000) {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      try {
        const status = await this.connection.getSignatureStatus(signature);
        
        if (status && status.value) {
          if (status.value.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(status.value.err)}`);
          }
          
          if (status.value.confirmationStatus === commitment || 
              status.value.confirmationStatus === 'finalized') {
            console.log(`✅ Transaction confirmed via Helius: ${signature}`);
            return status.value;
          }
        }
        
        // Check every 1 second with Helius speed
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        console.log(`⚠️ Error checking transaction status: ${error.message}`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    throw new Error(`Transaction confirmation timeout after ${timeout}ms`);
  }

  /**
   * Create wallet from private key
   */
  createWalletFromPrivateKey(privateKey) {
    try {
      // Handle both base58 string and byte array formats
      let privateKeyBytes;
      
      if (typeof privateKey === 'string') {
        // Try base58 decode first (standard Solana format)
        try {
          privateKeyBytes = bs58.decode(privateKey);
        } catch {
          // Try JSON array format: [1,2,3,...,64]
          try {
            privateKeyBytes = new Uint8Array(JSON.parse(privateKey));
          } catch {
            throw new Error('Invalid private key format');
          }
        }
      } else if (Array.isArray(privateKey)) {
        privateKeyBytes = new Uint8Array(privateKey);
      } else {
        throw new Error('Private key must be string or array');
      }

      if (privateKeyBytes.length !== 64) {
        throw new Error('Private key must be 64 bytes');
      }

      return Keypair.fromSecretKey(privateKeyBytes);
    } catch (error) {
      throw new Error(`Invalid Solana private key: ${error.message}`);
    }
  }

  /**
   * Generate new wallet
   */
  generateWallet() {
    const keypair = Keypair.generate();
    return {
      privateKey: bs58.encode(keypair.secretKey),
      address: keypair.publicKey.toString(),
      keypair: keypair
    };
  }

  /**
   * Validate Solana address format
   */
  isValidAddress(address) {
    try {
      if (!address || typeof address !== 'string') {
        return false;
      }
      
      // Basic length check (Solana addresses are typically 32-44 characters)
      if (address.length < 32 || address.length > 44) {
        return false;
      }
      
      new PublicKey(address);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Calculate fee for a trade
   */
  calculateFee(amount, feePercentage = 1.0) {
    const amountNum = parseFloat(amount);
    const feeAmount = amountNum * (feePercentage / 100);
    return {
      originalAmount: amountNum,
      feeAmount: feeAmount,
      finalAmount: amountNum - feeAmount,
      feePercentage: feePercentage
    };
  }

  /**
   * Get network status via Helius
   */
  async getNetworkStatus() {
    try {
      const [slot, epoch, health] = await Promise.all([
        this.connection.getSlot(),
        this.connection.getEpochInfo(),
        this.connection.getHealth()
      ]);

      return {
        slot,
        epoch: epoch.epoch,
        health: health === 'ok' ? 'healthy' : 'degraded',
        network: 'mainnet-beta',
        provider: 'helius'
      };
    } catch (error) {
      return {
        health: 'unhealthy',
        error: error.message,
        provider: 'helius'
      };
    }
  }

  /**
   * Stop subscription
   */
  async stopSubscription(subscriptionId) {
    try {
      await this.connection.removeAccountChangeListener(subscriptionId);
      console.log(`🛑 Stopped Helius subscription: ${subscriptionId}`);
    } catch (error) {
      console.log(`⚠️ Failed to stop subscription: ${error.message}`);
    }
  }
}

module.exports = SolChain;