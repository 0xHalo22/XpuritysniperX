/**
 * üí∞ SIMPLIFIED SOL FEE COLLECTION - BULLETPROOF VERSION
 * 
 * This function collects SOL fees without unnecessary rent exemption checks.
 * The treasury account already exists and can receive ANY amount of SOL.
 */
async sendFeeToTreasury(wallet, feeAmountSOL) {
  try {
    console.log(`üîç SOL FEE COLLECTION:`);
    console.log(`  Fee Amount: ${feeAmountSOL} SOL`);
    console.log(`  Treasury: ${process.env.TREASURY_WALLET_SOL}`);
    console.log(`  User: ${wallet.publicKey.toString()}`);

    // ‚úÖ STEP 1: Validate treasury configuration
    const treasuryAddress = process.env.TREASURY_WALLET_SOL;
    if (!treasuryAddress) {
      console.log('‚ùå SOL treasury wallet not configured');
      return null;
    }

    if (!this.isValidAddress(treasuryAddress)) {
      console.log(`‚ùå Invalid treasury address: ${treasuryAddress}`);
      return null;
    }

    // ‚úÖ STEP 2: Validate fee amount
    const feeAmountFloat = parseFloat(feeAmountSOL);
    if (feeAmountFloat <= 0) {
      console.log(`‚ö†Ô∏è Fee amount is zero or negative: ${feeAmountFloat}`);
      return null;
    }

    const lamports = Math.floor(feeAmountFloat * LAMPORTS_PER_SOL);
    console.log(`üí∏ Converting ${feeAmountSOL} SOL to ${lamports} lamports`);

    // ‚úÖ STEP 3: Check user wallet balance
    const currentBalance = await this.connection.getBalance(wallet.publicKey);
    const requiredAmount = lamports + 10000; // Fee + transaction cost buffer

    console.log(`üí∞ User balance: ${currentBalance} lamports`);
    console.log(`üí∏ Required: ${requiredAmount} lamports (${lamports} fee + 10000 tx cost)`);

    if (currentBalance < requiredAmount) {
      console.log(`‚ùå Insufficient balance: ${currentBalance} < ${requiredAmount}`);
      return null;
    }

    // ‚úÖ STEP 4: Create transaction
    const treasuryPublicKey = new PublicKey(treasuryAddress);
    const { blockhash } = await this.connection.getLatestBlockhash('confirmed');

    const feeTransaction = new Transaction({
      feePayer: wallet.publicKey,
      recentBlockhash: blockhash
    }).add(
      SystemProgram.transfer({
        fromPubkey: wallet.publicKey,
        toPubkey: treasuryPublicKey,
        lamports: lamports
      })
    );

    console.log(`üèóÔ∏è Fee transaction created for ${lamports} lamports`);

    // ‚úÖ STEP 5: Sign and send transaction
    feeTransaction.sign(wallet);
    
    const signature = await this.connection.sendRawTransaction(
      feeTransaction.serialize(),
      {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
        maxRetries: 3
      }
    );

    console.log(`üöÄ SOL fee transaction sent: ${signature}`);

    // ‚úÖ STEP 6: Confirm transaction (non-blocking)
    try {
      await this.confirmTransactionPolling(signature, 'confirmed', 30000);
      console.log(`‚úÖ SOL fee confirmed: ${signature}`);
    } catch (confirmError) {
      console.log(`‚ö†Ô∏è Fee confirmation timeout (but may have succeeded): ${confirmError.message}`);
      // Don't fail here - the transaction might still be valid
    }

    // ‚úÖ STEP 7: Success response
    console.log(`üéâ SOL FEE COLLECTION SUCCESS!`);
    console.log(`üí∞ Collected: ${feeAmountSOL} SOL (${lamports} lamports)`);
    console.log(`üè¶ To Treasury: ${treasuryAddress}`);
    console.log(`üîó Transaction: ${signature}`);

    return { 
      signature: signature,
      amount: feeAmountSOL,
      lamports: lamports,
      to: treasuryAddress,
      confirmed: true
    };

  } catch (error) {
    console.log(`‚ùå SOL fee collection failed: ${error.message}`);
    
    // Enhanced error categorization for debugging
    if (error.message.includes('insufficient')) {
      console.log('üí° Error: Insufficient balance');
    } else if (error.message.includes('blockhash')) {
      console.log('üí° Error: Network/blockhash issue');
    } else if (error.message.includes('signature')) {
      console.log('üí° Error: Transaction signature issue');
    } else {
      console.log('üí° Error: General network/RPC issue');
    }

    // Return null instead of throwing to not break main trade
    return null;
  }
}