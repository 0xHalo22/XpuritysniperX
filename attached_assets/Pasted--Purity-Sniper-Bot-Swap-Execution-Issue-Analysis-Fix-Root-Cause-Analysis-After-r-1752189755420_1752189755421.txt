# 🔍 Purity Sniper Bot - Swap Execution Issue Analysis & Fix

## 🚨 **Root Cause Analysis**

After reviewing your codebase, I've identified several critical issues preventing on-chain swaps:

### **1. Token Approval Missing**
Your swap execution skips the crucial token approval step for ERC-20 tokens. For any token → ETH or token → token swap, you must first approve the Uniswap router to spend tokens.

### **2. Incomplete Transaction Building**
The `buildETHToTokenSwap` and `buildTokenToETHSwap` functions create transaction data but don't properly handle:
- Gas estimation integration
- Proper nonce management
- Fee collection integration

### **3. Wallet Instance Management Issues**
The `getWalletForTrading` function in index.js creates wallet instances but doesn't properly interface with the transaction execution system.

### **4. Missing Transaction Confirmation**
Transactions are sent but not properly waited for confirmation, leading to potential race conditions.

---

## 🛠️ **Critical Fixes Required**

### **Fix 1: Add Token Approval Flow**

In `chains/eth.js`, add this before any token swap:

```javascript
async executeTokenSwapWithApproval(tokenIn, tokenOut, amountIn, privateKey, slippagePercent = 3) {
  const provider = await this.getProvider();
  const wallet = new ethers.Wallet(privateKey, provider);
  
  // Step 1: Check if token approval is needed
  if (tokenIn !== this.contracts.WETH && tokenIn !== ethers.constants.AddressZero) {
    console.log(`🔍 Checking token approval for ${tokenIn}`);
    
    const allowance = await this.getTokenAllowance(
      tokenIn, 
      wallet.address, 
      this.contracts.UNISWAP_V2_ROUTER
    );
    
    if (allowance.lt(amountIn)) {
      console.log(`⚠️ Insufficient allowance. Approving token...`);
      
      const approvalTx = await this.approveToken(
        tokenIn,
        this.contracts.UNISWAP_V2_ROUTER,
        ethers.constants.MaxUint256, // Approve max for future trades
        privateKey
      );
      
      console.log(`⏳ Waiting for approval confirmation...`);
      await approvalTx.wait(1);
      console.log(`✅ Token approved!`);
    }
  }
  
  // Step 2: Execute the actual swap
  return await this.executeTokenSwap(tokenIn, tokenOut, amountIn, privateKey, slippagePercent);
}
```

### **Fix 2: Improve Transaction Building**

Replace the current swap execution in `index.js` with:

```javascript
// In the eth_buy_execute handler
async function executeEthBuyTrade(ctx, tokenAddress, amount, userId) {
  try {
    await ctx.editMessageText('⏳ **Step 1/3: Preparing transaction...**');
    
    const userData = await loadUserData(userId);
    const encryptedKey = userData.ethWallets[userData.activeWalletIndex || 0];
    
    // Decrypt wallet
    const privateKey = await walletManager.decryptWallet(encryptedKey, userId);
    const provider = await ethChain.getProvider();
    const wallet = new ethers.Wallet(privateKey, provider);
    
    // Calculate amounts
    const totalAmount = parseFloat(amount);
    const feePercent = userData.premium?.active ? 0.5 : 1.0;
    const feeAmount = totalAmount * (feePercent / 100);
    const netTradeAmount = totalAmount - feeAmount;
    
    console.log(`📊 Trade breakdown: Total ${totalAmount} ETH, Fee ${feeAmount} ETH, Trade ${netTradeAmount} ETH`);
    
    await ctx.editMessageText('⏳ **Step 2/3: Building swap transaction...**');
    
    // Build the swap transaction
    const amountInWei = ethers.utils.parseEther(netTradeAmount.toString());
    const swapQuote = await ethChain.getSwapQuote(
      ethChain.contracts.WETH,
      tokenAddress,
      amountInWei
    );
    
    const minAmountOut = ethers.BigNumber.from(swapQuote.amountOut)
      .mul(97).div(100); // 3% slippage
    
    const swapTx = await ethChain.buildETHToTokenSwap(
      tokenAddress,
      amountInWei,
      minAmountOut,
      wallet.address
    );
    
    // Add gas estimation
    const gasEstimate = await provider.estimateGas({
      ...swapTx,
      from: wallet.address
    });
    
    const gasPrice = await provider.getGasPrice();
    const transaction = {
      ...swapTx,
      gasLimit: gasEstimate.mul(120).div(100), // 20% buffer
      gasPrice: gasPrice.mul(110).div(100), // 10% higher for faster execution
      nonce: await provider.getTransactionCount(wallet.address)
    };
    
    await ctx.editMessageText('⏳ **Step 3/3: Executing swap...**');
    
    // Send transaction
    const txResponse = await wallet.sendTransaction(transaction);
    console.log(`✅ Swap transaction sent: ${txResponse.hash}`);
    
    // Update UI immediately
    await ctx.editMessageText(
      `✅ **Swap Transaction Sent!**
      
🔗 **Transaction Hash:** \`${txResponse.hash}\`
💰 **Amount:** ${netTradeAmount} ETH
🎯 **Token:** \`${tokenAddress}\`
⏳ **Status:** Pending confirmation...

[View on Etherscan](https://etherscan.io/tx/${txResponse.hash})`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🔄 Check Status', callback_data: `check_tx_${txResponse.hash}` }],
            [{ text: '🔙 Back to ETH Menu', callback_data: 'chain_eth' }]
          ]
        },
        parse_mode: 'Markdown'
      }
    );
    
    // Wait for confirmation in background
    confirmTransactionInBackground(txResponse, ctx, userId, 'buy', {
      tokenAddress,
      amount: netTradeAmount,
      feeAmount
    });
    
    // Collect fee after main transaction (non-blocking)
    if (feeAmount > 0) {
      collectFeeInBackground(privateKey, feeAmount, userId);
    }
    
  } catch (error) {
    console.error('❌ Swap execution failed:', error);
    await ctx.editMessageText(
      `❌ **Swap Failed**
      
**Error:** ${error.message}

Please try again with a smaller amount or check your wallet balance.`,
      {
        reply_markup: {
          inline_keyboard: [
            [{ text: '🔄 Try Again', callback_data: 'eth_buy' }],
            [{ text: '🔙 Back to ETH Menu', callback_data: 'chain_eth' }]
          ]
        }
      }
    );
  }
}
```

### **Fix 3: Background Transaction Confirmation**

Add these helper functions to `index.js`:

```javascript
async function confirmTransactionInBackground(txResponse, ctx, userId, type, details) {
  try {
    console.log(`⏳ Waiting for confirmation: ${txResponse.hash}`);
    
    // Wait up to 5 minutes for confirmation
    const receipt = await Promise.race([
      txResponse.wait(1),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Confirmation timeout')), 300000)
      )
    ]);
    
    if (receipt && receipt.status === 1) {
      console.log(`✅ Transaction confirmed! Block: ${receipt.blockNumber}`);
      
      // Save to transaction history
      await saveTransactionToHistory(userId, {
        hash: txResponse.hash,
        type: type,
        status: 'confirmed',
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed.toString(),
        ...details,
        timestamp: Date.now()
      });
      
      // Notify user of confirmation (optional)
      try {
        await ctx.telegram.sendMessage(
          ctx.chat.id,
          `🎉 **Transaction Confirmed!**
          
Your ${type} transaction has been confirmed on-chain.
Block: ${receipt.blockNumber}
Hash: \`${txResponse.hash}\``,
          { parse_mode: 'Markdown' }
        );
      } catch (notifyError) {
        console.log('Could not send confirmation notification:', notifyError.message);
      }
      
    } else {
      throw new Error('Transaction failed on-chain');
    }
    
  } catch (error) {
    console.error(`❌ Transaction confirmation failed: ${error.message}`);
    
    // Save failed transaction
    await saveTransactionToHistory(userId, {
      hash: txResponse.hash,
      type: type,
      status: 'failed',
      error: error.message,
      ...details,
      timestamp: Date.now()
    });
  }
}

async function collectFeeInBackground(privateKey, feeAmount, userId) {
  try {
    console.log(`💰 Collecting fee in background: ${feeAmount} ETH`);
    
    const feeResult = await ethChain.collectFee(privateKey, feeAmount.toString());
    
    if (feeResult) {
      console.log(`✅ Fee collected successfully: ${feeResult.hash}`);
      
      // Save fee transaction
      await saveTransactionToHistory(userId, {
        hash: feeResult.hash,
        type: 'fee',
        status: 'sent',
        amount: feeAmount.toString(),
        timestamp: Date.now()
      });
    }
    
  } catch (feeError) {
    console.error(`⚠️ Fee collection failed (non-blocking): ${feeError.message}`);
  }
}
```

### **Fix 4: Environment Validation**

Add this check to your startup:

```javascript
// Add to index.js startup
async function validateEnvironment() {
  const required = ['BOT_TOKEN', 'ETH_RPC_URL', 'TREASURY_WALLET'];
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  
  // Test RPC connection
  try {
    const provider = new ethers.providers.JsonRpcProvider(process.env.ETH_RPC_URL);
    const blockNumber = await provider.getBlockNumber();
    console.log(`✅ Connected to Ethereum mainnet, block: ${blockNumber}`);
  } catch (error) {
    throw new Error(`Failed to connect to Ethereum RPC: ${error.message}`);
  }
  
  // Validate treasury wallet
  if (!ethers.utils.isAddress(process.env.TREASURY_WALLET)) {
    throw new Error('TREASURY_WALLET is not a valid Ethereum address');
  }
  
  console.log('✅ Environment validation passed');
}
```

---

## 🎯 **Quick Implementation Steps**

1. **Update chains/eth.js** - Add the `executeTokenSwapWithApproval` function
2. **Update index.js** - Replace buy/sell execution with proper transaction handling
3. **Add background confirmation** - Implement the helper functions above
4. **Test with small amounts** - Start with 0.001 ETH trades to verify functionality
5. **Monitor transactions** - Check Etherscan to confirm on-chain execution

---

## 🔧 **Testing Checklist**

- [ ] Environment variables properly set
- [ ] RPC connection working
- [ ] Wallet import/encryption working
- [ ] Token approval working for ERC-20 trades
- [ ] ETH → Token swaps executing on-chain
- [ ] Token → ETH swaps executing on-chain
- [ ] Fee collection working
- [ ] Transaction confirmation tracking
- [ ] Error handling for failed transactions

---

## 🚨 **Next Steps**

1. **Implement these fixes immediately** - This will resolve the on-chain execution
2. **Test with mainnet small amounts** - Use 0.001-0.01 ETH for initial testing
3. **Monitor console logs** - Check for transaction hashes and confirmations
4. **Verify on Etherscan** - Confirm transactions appear on blockchain

The core issue is that your transaction building is incomplete and missing the approval flow. Once these fixes are implemented, your swaps will execute on-chain successfully!